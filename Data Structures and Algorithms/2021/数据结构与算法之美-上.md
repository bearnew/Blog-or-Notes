# 数据结构与算法之美-上

## 1.高效学习数据结构与算法

1. 数据结构是要为算法服务的，算法要作用在特定的数据结构上
2. 常用的 10 个数据结构
   - 数组
   - 链表
   - 栈
   - 队列
   - 散列表
   - 二叉树
   - 堆
   - 跳表
   - 图
   - Trie 树
3. 常用的 10 个算法
   - 递归
   - 排序
   - 二分查找
   - 搜索
   - 哈希算法
   - 贪心算法
   - 分治算法
   - 回溯算法
   - 动态规划
   - 字符串匹配算法

## 2.时间复杂度

1. 大 O 复杂度表示法
   - 常量阶`O(1)`
   - 对数阶`O(logn)`
   - 线性阶`O(n)`
   - 线性对数阶`O(nlogn)`
   - 平方阶`O(n^2)`
   - 立方阶`O(n^3)`
   - k 次方阶`O(n^k)`
   - 指数阶`O(2^n)`
   - 阶乘阶`O(n!)`
2. 时间复杂度
   - 只关注循环执行次数最多的一段代码
   - 加法法则：总复杂度等于量级最大的那段代码的复杂度
   - 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
3. `O(1)`

   - 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 Ο(1)。
   - `example`

   ```c
   int i = 8;
   int j = 6;
   int sum = i + j;
   ```

4. `O(logn)、O(nlogn)`
   - 所有对数阶的时间复杂度都记为 `O(logn)`
     ```js
     i = 1;
     while (i <= n) {
       i = i * 3;
     }
     ```
   - 一段代码的时间复杂度是 `O(logn)`，我们循环执行 n 遍，时间复杂度就是 `O(nlogn)` 了
     - 归并排序
     - 快速排序
5. `O(m+n)、O(m\*n)`

   - 代码的复杂度由 2 个数据规模来决定

   ```c
   int cal(int m, int n) {
      int sum_1 = 0;
      int i = 1;
      for (; i < m; ++i) {
         sum_1 = sum_1 + i;
      }

      int sum_2 = 0;
      int j = 1;
      for (; j < n; ++j) {
         sum_2 = sum_2 + j;
      }

      return sum_1 + sum_2;
   }
   ```

6. 最好情况时间复杂度
7. 最坏情况时间复杂度
8. 平均情况时间复杂度
   - 加权平均时间复杂度
   - 期望时间复杂度
9. 均摊时间复杂度
   - 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

## 3.空间复杂度

1. 常见的空间复杂度是`O(1) O(n) O(n^2)`

```c
// 空间复杂度为O(n)
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

## 4.数组

1. 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类的数据。
   - 线性表：数组、链表、队列、栈
   - 非线性表：二叉树、堆、图
   - 连续的内存空间和相同类型的数据
     - 数组支持随机访问，时间复杂度为 O(1)
     - 链表适合插入、删除，时间复杂度为 O(1)
2. 数组的索引从 0 开始，0 是代表相对于首地址的偏移

## 5.链表

1. 缓存的 3 种策略
   - 先进先出策略`FIFO`(`First In`，`First Out`)
   - 最少使用策略`LFU`(`Least Frequently Used`)
   - 最近最少使用策略`LRU`(`Least Recently Used`)
2. 存储结构
   - 数组需要连续的内存空间来存储
   - 链表通过指针将一组零散的内存块串联起来使用
3. 链表的结点
   - 头结点用来记录链表的基地址
   - 尾节点指向一个`空地址NULL`
4. 查找、插入、删除
   - 数组的插入和删除，为了保持内存的连续性，需要做大量的数据搬移，时间复杂度为`O(n)`
   - 链表不需要，所在，在链表中插入和删除一个数据非常迅速，复杂度为`O(1)`
   - 查找需要从第 1 个元素开始，需要`O(n)`的复杂度
5. 循环链表
   - 循环链表的尾节点指向链表的头节点
6. 双向链表
   - 单链表只有 1 个方向，结点只有 1 个后继指针`next`指向后面的节点
   - 双链表不仅有 1 个后继指针`next`指向后面的节点，还有 1 个前驱指针`prev`指向前面的结点
   - 双链表需要额外的两个空间来存储后继结点和前驱结点的地址，需要占用更多的内存空间
   - 双链表支持双向遍历，带来了更多的灵活性
7. 链表实现`LRU`缓存
   1. 数据存在缓存中，会遍历链表，将原来的结点删除，然后插入链表的头部
   2. 数据不存在缓存中
      - 缓存未满，将结点直接插入链表的头部
      - 缓存已满，则删除链表尾结点，将新数据结点插入链表的头部
      - 时间复杂度为`O(n)`
8. 指针/引用
   - 将某个变量赋值给指针，实际上是将变量的地址赋值给指针
9. 链表常见考题
   - 单链表反转
   - 链表中环的检测
   - 两个有序的链表合并
   - 删除链表倒数第 n 个结点
   - 求链表的中间结点

## 6.栈

1. 后进者先出，先进者后出
2. 栈是一种操作受限的线性表，只允许一端插入和删除数据
3. 数组实现的栈顺序栈，链表实现的栈链式栈
4. 入栈和出栈的空间复杂度和时间复杂度都是 O(1)
5. 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。
6. 页面的前进后退
   - 使用 2 个栈，X 栈和 Y 栈
   - 首次浏览的页面依次压入栈 X 中
   - 点击后退按钮时，依次从 X 中出栈，将出栈的数据放入栈 Y 中
   - 点击前进按钮时，依次总 Y 中出栈，将出栈的数据放入栈 X 中

## 7.队列

1.
